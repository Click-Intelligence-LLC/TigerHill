# CLI Interactive Testing Template
# Tests interactive CLI applications with user input

metadata:
  name: "cli-interactive"
  display_name: "CLI Interactive Testing"
  description: "Test interactive CLI applications with multi-step user input"
  category: "cli"
  version: "1.0.0"
  author: "TigerHill"
  tags: ["cli", "interactive", "stdin", "prompts"]

parameters:
  - name: "agent_name"
    display_name: "Agent Name"
    description: "Name for the test agent"
    type: "string"
    required: true
    default: "my-interactive-agent"
    validation:
      pattern: "^[a-zA-Z0-9_-]+$"

  - name: "command"
    display_name: "Command"
    description: "The interactive CLI command to execute"
    type: "string"
    required: true

  - name: "num_interactions"
    display_name: "Number of Interactions"
    description: "Number of input/output interactions"
    type: "integer"
    required: true
    default: 3
    validation:
      min: 1
      max: 10

  - name: "timeout"
    display_name: "Timeout (seconds)"
    description: "Timeout for each interaction"
    type: "integer"
    required: true
    default: 30
    validation:
      min: 1
      max: 300

dependencies:
  pip:
    - "pytest>=7.4.0"
    - "pexpect>=4.8.0"

files:
  - path: "test_{{agent_name}}.py"
    template: "main_script"
  - path: "requirements.txt"
    template: "requirements"
  - path: "README.md"
    template: "readme"

templates:
  main_script: |
    #!/usr/bin/env python3
    """
    {{ metadata.display_name }} - Generated by TigerHill

    {{ metadata.description }}
    """

    import pytest
    import pexpect
    from tigerhill.storage.trace_store import TraceStore, EventType


    class Test{{ agent_name | camel_case }}:
        """{{ metadata.display_name }} Test Suite"""

        @pytest.fixture
        def trace_store(self, tmp_path):
            """Create trace store for recording"""
            return TraceStore(storage_path=str(tmp_path))

        def test_{{ agent_name | snake_case }}(self, trace_store):
            """Test {{ metadata.display_name }}"""

            # Start trace
            trace_id = trace_store.start_trace(
                agent_name="{{ agent_name }}",
                task_id="interactive-test-{{ agent_name }}",
                metadata={
                    "command": "{{ command }}",
                    "interactions": {{ num_interactions }}
                }
            )

            try:
                # Spawn interactive process
                child = pexpect.spawn("{{ command }}", timeout={{ timeout }})

                {% for i in range(num_interactions) -%}
                # Interaction {{ i + 1 }}
                # Wait for prompt (customize the expected pattern)
                child.expect(".*[>:?]\\s*$", timeout={{ timeout }})

                prompt_text = child.before.decode('utf-8') if child.before else ""

                trace_store.write_event(
                    {
                        "type": "cli_prompt",
                        "interaction": {{ i + 1 }},
                        "prompt": prompt_text
                    },
                    trace_id=trace_id
                )

                # Send input (customize for your application)
                input_text = "Test input {{ i + 1 }}"
                child.sendline(input_text)

                trace_store.write_event(
                    {
                        "type": "cli_input",
                        "interaction": {{ i + 1 }},
                        "input": input_text
                    },
                    trace_id=trace_id
                )

                print(f"  {{ i + 1 }}. Sent: {input_text}")

                {% endfor -%}

                # Wait for final output or exit
                try:
                    child.expect(pexpect.EOF, timeout={{ timeout }})
                    final_output = child.before.decode('utf-8') if child.before else ""

                    trace_store.write_event(
                        {
                            "type": "cli_output",
                            "output": final_output
                        },
                        trace_id=trace_id
                    )

                except pexpect.TIMEOUT:
                    # Terminate if still running
                    child.terminate()

                # Check exit code
                child.close()
                exit_code = child.exitstatus

                trace_store.write_event(
                    {
                        "type": "cli_exit",
                        "exit_code": exit_code
                    },
                    trace_id=trace_id
                )

                assert exit_code == 0, f"Expected exit code 0, got {exit_code}"

                print(f"âœ… Test passed: {{ agent_name }}")
                print(f"Completed {{ num_interactions }} interactions")

            except Exception as e:
                trace_store.write_event(
                    {
                        "type": "error",
                        "error_message": str(e),
                        "error_type": type(e).__name__
                    },
                    trace_id=trace_id,
                    event_type=EventType.ERROR
                )
                raise

            finally:
                # End trace
                trace_store.end_trace(trace_id)


    if __name__ == "__main__":
        pytest.main([__file__, "-v", "-s"])

  requirements: |
    # Generated by TigerHill Template Library
    # Template: {{ metadata.name }}
    {% for dep in dependencies.pip -%}
    {{ dep }}
    {% endfor %}

  readme: |
    # {{ metadata.display_name }}

    {{ metadata.description }}

    ## Generated Configuration

    - **Agent Name**: `{{ agent_name }}`
    - **Command**: `{{ command }}`
    - **Interactions**: `{{ num_interactions }}`
    - **Timeout**: `{{ timeout }}` seconds

    ## Installation

    ```bash
    pip install -r requirements.txt
    ```

    ## Usage

    Run the test:

    ```bash
    pytest test_{{ agent_name }}.py -v -s
    ```

    ## Customization

    Customize the test for your specific interactive CLI:

    1. **Modify prompt patterns**: Update `child.expect()` patterns to match your CLI's prompts
    2. **Customize inputs**: Replace "Test input N" with actual test inputs
    3. **Add assertions**: Validate specific outputs or behaviors
    4. **Handle special cases**: Add logic for error states, confirmations, etc.

    ## Documentation

    For more information, see:
    - [TigerHill Documentation](https://github.com/yourusername/tigerhill)
    - [CLI Testing Guide](https://github.com/yourusername/tigerhill/docs/cli_testing.md)
    - [pexpect Documentation](https://pexpect.readthedocs.io/)
